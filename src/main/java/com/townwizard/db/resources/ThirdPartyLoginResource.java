package com.townwizard.db.resources;

import static com.townwizard.db.constants.Constants.FB_APP_ID;
import static com.townwizard.db.constants.Constants.FB_APP_SECRET;
import static com.townwizard.db.constants.Constants.FB_LOGIN_RESOURCE;
import static com.townwizard.db.constants.Constants.PHP_LOGIN_PATH;
import static com.townwizard.db.constants.Constants.TWITTER_APP_ID;
import static com.townwizard.db.constants.Constants.TWITTER_APP_SECRET;
import static com.townwizard.db.constants.Constants.TWITTER_LOGIN_RESOURCE;

import java.net.URL;
import java.net.URLEncoder;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

import org.scribe.builder.ServiceBuilder;
import org.scribe.builder.api.TwitterApi;
import org.scribe.model.Token;
import org.scribe.model.Verifier;
import org.scribe.oauth.OAuthService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.townwizard.db.model.LoginRequest;
import com.townwizard.db.model.User;
import com.townwizard.db.model.User.LoginType;
import com.townwizard.db.services.UserService;
import com.townwizard.db.util.HttpUtils;
import com.townwizard.db.util.StringUtils;

/**
 * Contains a REST resource to facilitate Facebook and Twitter login
 */
@Component
@Path("/login")
public class ThirdPartyLoginResource extends ResourceSupport {
  
    @Autowired
    private UserService userService;
    
    /**
     * Handles requests generated by the Facebook login workflow.  The requests come from Facebook
     * as well as the original partner site.
     * 
     * The parameters passed to this service define its behavior.  The available parameters are:
     *  - code        An access code generated by Facebook, necessary to retrieve private user data
     *  - state       An intermediate UUID token necessary to recognize subsequent calls to the service.
     *                This token is generated by the service, passed to Facebook, and then passed by 
     *                Facebook back to the service.
     *  - location    An original partner URL from which the user is logging into Facebook     *  
     *  
     * Three different calls can be made to this service during the Facebook login workflow.
     * 
     * Call 1: 
     * 
     * Happens when a user clicks on the facebook login button on the partner site page.
     * At this point no state, access code, or user id is known.  The partner site will pass the
     * original location only as a GET parameter.  This call is handled by generating the unique 
     * state and sending it to the facebook authentication URL
     * 
     * Call 2:
     * 
     * Happens when the user clicks cancel on the facebook login window. This call will be handled
     * by sending Javascript back which will close the facebook popup window.
     * 
     * Call 3:
     * 
     * Happens when the user proceeds with login, or when the user is already logged in Facebook, and
     * Facebook realizes that fact (successful login).  This call comes from Facebook and it contains
     * the access code and the state (login request id) passed back from Facebook.
     * 
     * Upon receiving this call, the service will make another back-end call to facebook in order to
     * retrieve user data (now that the service has a valid access code it can do it). When the user
     * data is retrieved, the user is created/updated in the Townwizard DB database.
     * 
     * After that, it's necessary to redirect the popup window back to the partner site, otherwise
     * it would not by possible to refresh the main browser window due to the browser security
     * restrictions.
     * 
     * This is done by sending a javascript tag to the popup.
     * 
     * The original location and the user id are passed to the partner site, and it will close
     * the popup and redirect to the original url.
     */
    @GET
    @Path("/fb")
    @Produces(MediaType.TEXT_HTML)
    public Response loginWithFacebook(
            @QueryParam("code") String code,
            @QueryParam("state") String loginRequestId,
            @QueryParam("l") String location) {
        try {
            if(code == null && loginRequestId == null && location != null) {                
                return handleUserLoginRequest(LoginType.FACEBOOK, location);
            }
            
            if(code == null && loginRequestId != null && location == null) {
                return handleUserLoginDenialRequest();
            }
            
            LoginRequest lRequest;
            if(code != null && (lRequest = userService.getLoginRequest(loginRequestId)) != null) {
                return handleUserLogin(LoginType.FACEBOOK, lRequest, code);
            }          
        } catch(Exception e) {
            handleGenericException(e);
        }
        
        return Response.status(Status.BAD_REQUEST).build();
    }
    
    /**
     *  Handles three calls made when a user sings in using Twitter account.  Also, see comments on the facebook
     *  login method.
     *  
     *   Call 1: 
     *   
     *   Happens when a user clicks on the "Sign in with Twitter button"
     *   
     *   Call 2:
     *   
     *   Happens when the user denies Twitter login
     *   
     *   Call 3:
     *   
     *   Happens when the user proceeds with login
     */
    @GET
    @Path("/twitter")
    @Produces(MediaType.TEXT_HTML)
    public Response loginWithTwitter(
            @QueryParam("oauth_verifier") String code,
            @QueryParam("oauth_token") String loginRequestId,
            @QueryParam("l") String location,            
            @QueryParam("denied") String denied) {
        try {
            if(code == null && loginRequestId == null && location != null) {
                return handleUserLoginRequest(LoginType.TWITTER, location);
            }            
           
            if(denied != null) {
                return handleUserLoginDenialRequest();
            }
            
            LoginRequest lRequest;
            if(code != null && (lRequest = userService.getLoginRequest(loginRequestId)) != null) {
                return handleUserLogin(LoginType.TWITTER, lRequest, code);
            }
        } catch(Exception e) {
            handleGenericException(e);
        }
    
        return Response.status(Status.BAD_REQUEST).build();
    }
    
    //Call 1 handler for FB and Twitter (login initiation)
    //Thie method saves login request into DB, generates authentication url,
    //and response to the client with JS redirecting to the authentication url
    private Response handleUserLoginRequest(LoginType loginType, String location) {        
        String lRequestId = null;
        String authUrl = null;
        if(loginType == LoginType.FACEBOOK) {
            lRequestId = UUID.randomUUID().toString();
            StringBuilder dialogUrl = new StringBuilder();
            dialogUrl.append("https://www.facebook.com/dialog/oauth?");
            dialogUrl.append("client_id=").append(FB_APP_ID);
            dialogUrl.append("&redirect_uri=").append(FB_LOGIN_RESOURCE);
            dialogUrl.append("&state=").append(lRequestId);
            dialogUrl.append("&display=popup");
            dialogUrl.append("&scope=email");
            authUrl = dialogUrl.toString();
        } else { //TWITTER
            OAuthService service = new ServiceBuilder()
                .provider(TwitterApi.Authenticate.class)
                .apiKey(TWITTER_APP_ID)
                .apiSecret(TWITTER_APP_SECRET)
                .callback(TWITTER_LOGIN_RESOURCE)                
                .build();
            Token requestToken = service.getRequestToken();
            lRequestId = requestToken.getToken();
            authUrl = service.getAuthorizationUrl(requestToken);            
        }
        
        String html = getJavaScriptHtml("window.location.href='" + authUrl + "'");
        userService.createLoginRequest(new LoginRequest(lRequestId, location, new Date()));        
        return Response.status(Status.OK).entity(html).build();
    }
    
    //Call 2 handler for FB and Twitter (login denial)
    //Sends response with JS closing the dialog
    private Response handleUserLoginDenialRequest() {
        String html = getJavaScriptHtml("window.close();");
        return Response.status(Status.OK).entity(html).build();        
    }
    
    //Call 3 handler for FB and Twitter (actual login)
    //Give acess code makes a request to the site to get user info, updates the info in the DB,
    //and responses with javascript redirecting the client to its original location
    private Response handleUserLogin(LoginType loginType, LoginRequest loginRequest, String accessCode) 
            throws Exception {        
        String userJson = null;
        if(loginType == LoginType.FACEBOOK) {
            userJson = getUserJsonFromFacebook(accessCode);
        } else { //TWITTER
            userJson = getUserJsonFromTwitter(loginRequest, accessCode);
        }        
        
        if(userJson != null) {
            Map<String, Object> user = parseJson(userJson);
            User u = User.fromExternalUser(user, loginType);
            createOrUpdateExternalUser(u);
            
            String server = getServerPartFromLocationUrl(loginRequest.getLocation());           
            StringBuilder javaScript = new StringBuilder();
            javaScript.append("window.location.href='").append(server).append(PHP_LOGIN_PATH)
                .append("?uid=").append(u.getId()).append("&l=").append(loginRequest.getLocation()).append("';");
            String html = getJavaScriptHtml(javaScript.toString());
            return Response.status(Status.OK).entity(html).build();
        }

        return Response.status(Status.OK).entity("Server error").build();
    }
    
    private String getJavaScriptHtml(String javaScript) {
        StringBuffer html = new StringBuffer();
        html.append("<!DOCTYPE HTML>");
        html.append("<html><head><meta charset=\"UTF-8\"><meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\"></head><body><script>");
        html.append(javaScript);
        html.append("</script></body></html>");
        return html.toString();
    }
    
    private Map<String, String> parseAcessTokenResponse(String s) {
        //translate the line below into map (facebook)
        //access_token=AAAFT3VZBN5oQBAOqIik79TCYlzoJLBjtbZA5f3emRu5g0V37E6q5FR0t30sZBsAi3lQgY6ZBnIoxJZCMocr80zjgrkmBWyJtDvUrugshGjwZDZD&expires=5183326
        //or for twitter
        //oauth_token=28483095-ybhZ74geM4z4RMMhDnT6o6kw7CAHsovw1Lx5Mw&oauth_token_secret=b3mJPz2WDzh1nFhDIo27rOdojAVwe5SfFY642TxzBc&user_id=28483095&screen_name=j2vm
        Map<String, String> result = new HashMap<>();
        String[] data = s.split("&");
        for(String str : data) {
            String[] entry = str.split("=");
            if(entry.length == 2) {
                result.put(entry[0], entry[1]);
            }
        }                
        return result;        
    }
    
    private String getServerPartFromLocationUrl(String location) {
        try {
            URL url = new URL(location);
            String retVal = url.getProtocol() + "://" + url.getHost();
            return retVal;
        } catch (Exception e) {
            handleGenericException(e);
            return null;
        }
    }
    
    private void createOrUpdateExternalUser(User u) {
        User fromDb = userService.getByExternalIdAndLoginType(u.getExternalId(), u.getLoginType()); 
        if(fromDb != null) {
            u.setId(fromDb.getId());
            u.setCreated(fromDb.getCreated());
            u.setActive(fromDb.getActive());
            userService.update(u);
        } else {
            userService.create(u);
        }
    }
    
    private String getUserJsonFromFacebook(String accessCode) throws Exception {
        StringBuilder tokenUrl = new StringBuilder();
        tokenUrl.append("https://graph.facebook.com/oauth/access_token?");
        tokenUrl.append("client_id=").append(FB_APP_ID);
        tokenUrl.append("&redirect_uri=").append(FB_LOGIN_RESOURCE);
        tokenUrl.append("&client_secret=").append(FB_APP_SECRET);
        tokenUrl.append("&code=").append(accessCode);
        
        String response = HttpUtils.executeGetRequest(tokenUrl.toString());
        Map<String, String> accessInfo = parseAcessTokenResponse(response);
        String accessToken = accessInfo.get("access_token");            
        String userUrl = "https://graph.facebook.com/me?access_token=" + accessToken;
        String userJson = HttpUtils.executeGetRequest(userUrl);
        return userJson;
    }
    
    /*
     * Since twitter api v1.1 the user info request requires application to be authorized.
     * See details here: https://dev.twitter.com/docs/auth/application-only-auth
     */
    private String getUserJsonFromTwitter(LoginRequest loginRequest, String accessCode) throws Exception {
        // 1) get user id
        OAuthService service = new ServiceBuilder()
            .provider(TwitterApi.Authenticate.class)
            .apiKey(TWITTER_APP_ID)
            .apiSecret(TWITTER_APP_SECRET)
            .callback(TWITTER_LOGIN_RESOURCE)                
            .build();
    
        Token accessToken = service.getAccessToken(new Token(loginRequest.getId(), ""), new Verifier(accessCode));                
        String response = accessToken.getRawResponse();
        Map<String, String> accessInfo = parseAcessTokenResponse(response);
        String userId = accessInfo.get("user_id");
        
        if(userId != null) {
            //2) authorize request for user info
            Map<String, String> bearerTokenRequestHeaders = new HashMap<>();            
            bearerTokenRequestHeaders.put("Content-Type", "application/x-www-form-urlencoded;charset=UTF-8");
            bearerTokenRequestHeaders.put("Authorization", getTwitterEncodedBearerTokenCredentials());
            String entity = "grant_type=client_credentials";
            String bearerTokenResponse = HttpUtils.executePostRequest(
                    "https://api.twitter.com/oauth2/token", entity, bearerTokenRequestHeaders);
            
            //3) check validity of the bearer token response
            //response should look like
            //{"token_type":"bearer","access_token":"AAAAAAAAAAAAAAAAAAAAALDpPwAAAAAAaiOGc3h%2FsIY7OotyPtCv78jqQWc%3D0TWriks5cRmXKabi0yZyrQifWaUJaNnfx788iwdtqU"}
            String bearerToken = null;
            Map<String, Object> respData = parseJson(bearerTokenResponse);
            if("bearer".equals(respData.get("token_type"))) {
                bearerToken = (String)respData.get("access_token");
            }
        
            //4) execute user info request authorized with bearer token
            if(bearerToken != null) {
                String userUrl = "https://api.twitter.com/1.1/users/show.json?user_id=" + userId;
                Map<String, String> userInfoRequestHeaders = new HashMap<>();
                userInfoRequestHeaders.put("Authorization", "Bearer " + bearerToken);
                String userJson = HttpUtils.executeGetRequest(userUrl, userInfoRequestHeaders);
                return userJson;
            }
        }
        
        return null;
    }
    
    private static String ENCODED_TWITTER_BEARER_TOKEN_CREDENTIALS = null;
    private String getTwitterEncodedBearerTokenCredentials() throws Exception {
        if(ENCODED_TWITTER_BEARER_TOKEN_CREDENTIALS == null) {
            ENCODED_TWITTER_BEARER_TOKEN_CREDENTIALS = "Basic " + StringUtils.base64Encode(
                URLEncoder.encode(TWITTER_APP_ID, "UTF-8") + ":" +
                URLEncoder.encode(TWITTER_APP_SECRET, "UTF-8"));
        }
        return ENCODED_TWITTER_BEARER_TOKEN_CREDENTIALS;

    }

    //TODO: implement login request cleanup job
}
